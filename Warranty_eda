import pandas as pd

# 1) Ensure datetime/period monthly keys
df["WARRANTY_CLAIM_DATE"] = pd.to_datetime(df["WARRANTY_CLAIM_DATE"], errors="coerce")
dispatch["DISPATCH_MONTH"] = pd.to_datetime(dispatch["DISPATCH_MONTH"], errors="coerce")

# Use Period[M] keys for robust month joins/rolling by month
df["WARRANTY_CLAIM_MONTH"] = df["WARRANTY_CLAIM_DATE"].dt.to_period("M")
dispatch["DISPATCH_MONTH"] = dispatch["DISPATCH_MONTH"].dt.to_period("M")

# 2) Prepare a per-month dispatch series per MODEL/MODEL_FAMILY/PLANT
# Keep only needed columns and ensure VOLUME numeric
dispatch_use = dispatch[["PLANT", "MODEL", "MODEL_FAMILY", "DISPATCH_MONTH", "VOLUME"]].copy()
dispatch_use["VOLUME"] = pd.to_numeric(dispatch_use["VOLUME"], errors="coerce").fillna(0)

# 3) Build a continuous monthly index per group to support a 60-month rolling sum
# Reindex each group's monthly series to complete months, then rolling sum over 60 months
dispatch_use = (
    dispatch_use
    .set_index("DISPATCH_MONTH")
    .groupby(["PLANT", "MODEL", "MODEL_FAMILY"], group_keys=False)
    .apply(lambda g: (
        g["VOLUME"]
        .asfreq("M", fill_value=0)  # monthly frequency with zeros for missing months
        .rolling(window=60, min_periods=1).sum()  # last 60 months inclusive
        .to_frame("WARRANTY_POP_60M")
    ))
    .reset_index()
)
# Now dispatch_use has: PLANT, MODEL, MODEL_FAMILY, DISPATCH_MONTH (Period[M]), WARRANTY_POP_60M










# 4) Aggregate claims per month and join
# a) Claims count and amount per month/model/family/plant
claims_agg = (
    df.groupby(["PLANT", "MODEL", "MODEL_FAMILY", "WARRANTY_CLAIM_MONTH"])
      .agg(
          VEHICLE_CLAIMS=("WARRANTY_COST", "size"),
          WARRANTY_AMT=("WARRANTY_COST", "sum"),
      )
      .reset_index()
      .rename(columns={"WARRANTY_CLAIM_MONTH": "MONTH"})
)







# b) Map dispatch 60M population to the same month key
dispatch_60 = dispatch_use.rename(columns={"DISPATCH_MONTH": "MONTH"})

# 5) Combine: left join claims months to dispatch 60M pop (or outer if months exist without claims)
final = (
    claims_agg.merge(
        dispatch_60,
        on=["PLANT", "MODEL", "MODEL_FAMILY", "MONTH"],
        how="left"
    )
    .rename(columns={
        "WARRANTY_POP_60M": "NO_OF_VEHICLES_IN_WARRANTY",
        "VEHICLE_CLAIMS": "NO_OF_VEHICLE_CLAIMED",
        "WARRANTY_AMT": "AMT"
    })
)

# Optional: if rows with no dispatch history should show 0 instead of NaN
final["NO_OF_VEHICLES_IN_WARRANTY"] = final["NO_OF_VEHICLES_IN_WARRANTY"].fillna(0).astype("int64")

# 6) Optional: include months with dispatch but zero claims
# Build a complete month-by-model grid from dispatch_60 and left join claims in
base = dispatch_60.copy()
base = base[["PLANT", "MODEL", "MODEL_FAMILY", "MONTH", "WARRANTY_POP_60M"]].drop_duplicates()

final_all = (
    base.merge(
        claims_agg,
        on=["PLANT", "MODEL", "MODEL_FAMILY", "MONTH"],
        how="left"
    )
    .rename(columns={"WARRANTY_POP_60M": "NO_OF_VEHICLES_IN_WARRANTY"})
)
final_all["NO_OF_VEHICLE_CLAIMED"] = final_all["WARRANTY_COST"].fillna(0).astype("int64") if "WARRANTY_COST" in final_all else final_all["NO_OF_VEHICLE_CLAIMED"].fillna(0).astype("int64")
final_all["AMT"] = final_all["WARRANTY_AMT"].fillna(0.0)
final_all = final_all.drop(columns=[c for c in ["WARRANTY_AMT"] if c in final_all.columns])

