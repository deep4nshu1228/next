import pandas as pd

# Inputs:
# dispatch: PLANT, MODEL, MODEL_FAMILY, DISPATCH_MONTH, VOLUME
# claims_agg: PLANT, MODEL, MODEL_FAMILY, MONTH, NO_OF_VEHICLE_CLAIMED, AMT
# Assumptions: MONTH and DISPATCH_MONTH are month-level; we’ll set them to Period[M].

gcols = ["PLANT", "MODEL", "MODEL_FAMILY"]
global_start = pd.Period("2015-01", freq="M")
global_end   = pd.Period("2025-08", freq="M")  # stop at Aug-2025

# Normalize types
dispatch = dispatch.copy()
dispatch["DISPATCH_MONTH"] = pd.to_datetime(dispatch["DISPATCH_MONTH"], errors="coerce").dt.to_period("M")
dispatch["VOLUME"] = pd.to_numeric(dispatch["VOLUME"], errors="coerce").fillna(0)

claims_agg = claims_agg.copy()
claims_agg["MONTH"] = pd.to_datetime(claims_agg["MONTH"].astype(str), errors="coerce").dt.to_period("M")

# 1) Build a complete month grid per group from 2015-01 to 2025-08
groups = pd.concat([
    dispatch[gcols].drop_duplicates(),
    claims_agg[gcols].drop_duplicates()
]).drop_duplicates()

grids = []
for _, row in groups.iterrows():
    rng = pd.period_range(global_start, global_end, freq="M")
    grids.append(pd.DataFrame({
        "PLANT": row["PLANT"],
        "MODEL": row["MODEL"],
        "MODEL_FAMILY": row["MODEL_FAMILY"],
        "DISPATCH_MONTH": rng
    }))
month_grid = pd.concat(grids, ignore_index=True)

# 2) Join dispatch onto grid and fill zeros
dispatch_full = (
    month_grid.merge(dispatch[gcols + ["DISPATCH_MONTH", "VOLUME"]],
                     on=gcols + ["DISPATCH_MONTH"], how="left")
              .fillna({"VOLUME": 0})
)

# 3) Per-group rolling 60-month sum
# Choose inclusive of current month (includes this month’s volume), or exclusive by shifting one month.
dispatch_full = dispatch_full.sort_values(gcols + ["DISPATCH_MONTH"])

# Option A: inclusive (window includes current month)
pop_60 = (
    dispatch_full
      .set_index("DISPATCH_MONTH")
      .groupby(gcols)["VOLUME"]
      .rolling(window=60, min_periods=1).sum()
      .reset_index()
      .rename(columns={"VOLUME": "NO_OF_VEHICLES_IN_WARRANTY"})
)

# Option B: exclusive (exclude current month’s dispatch)
# pop_60 = (
#     dispatch_full
#       .assign(VOLUME_EXCL=lambda d: d.groupby(gcols)["VOLUME"].shift(1).fillna(0))
#       .set_index("DISPATCH_MONTH")
#       .groupby(gcols)["VOLUME_EXCL"]
#       .rolling(window=60, min_periods=1).sum()
#       .reset_index()
#       .rename(columns={"VOLUME_EXCL": "NO_OF_VEHICLES_IN_WARRANTY"})
# )

# 4) Align keys and month name
pop_60 = pop_60.rename(columns={"DISPATCH_MONTH": "MONTH"})

# 5) Merge ONLY the population into claims_agg
final = (
    claims_agg.merge(
        pop_60[gcols + ["MONTH", "NO_OF_VEHICLES_IN_WARRANTY"]],
        on=gcols + ["MONTH"],
        how="left"
    )
)

# Cleanup types
final["NO_OF_VEHICLES_IN_WARRANTY"] = final["NO_OF_VEHICLES_IN_WARRANTY"].fillna(0).astype("int64")
